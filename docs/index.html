<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <link rel="stylesheet" href="./docs.css">
</head>
<body>
  <main>
    <article>
      <section>
        <h2>Starting Up</h2>

        <p>
          When grueslayer (the execution mechanism of Entharion) starts up, it creates a <code>Cpu()</code> instance. The CPU abstraction loads a passed in zcode program and creates a bytes representation of that program. That bytes representation is wrapped in a <code>Memory()</code> instance.
        </p>

        <p>
          When the Memory instance is started, it creates a <code>Stack()</code> instance as well as establishes a variable for the program counter. I'll note here that in the specification it says: "The two important pieces of information not stored in memory are the program counter (PC) and the stack." Later on the specification says: "The stack is a second bank of memory, quite separate from the main one."
        </p>

        <p>
          In my case, I don't see a reason to have the stack be a "second bank of memory." So I just combine them. Similarly I don't see any logic to having the program counter not be a part of memory since, utlimately, the program counter is pointing to addresses in memory.
        </p>

        <p>
          Upon starting, the Memory instance also establishes the Z-Machine version of the program.
        </p>

        <pre>
          self.version: int = self.read_byte(0x00)
        </pre>

        <p>
          The specification says: "The first byte of any story file, and so the byte at memory address 0, always contains the version number of the Z-machine to be used." Note that this is not version of the program itself but, rather, the version of the Z-Machine that the program was designed to run with. That's important because different versions of the Z-Machine implemented different instruction sets and thus how processing of a zcode program took place could differ between the versions.
        </p>

        <p>
          Memory regions are also established.
        </p>

        <pre>
          self.dynamic: int = 0
          self.static: int = self.read_word(0x0E)
          self.high: int = self.read_word(0x04)
        </pre>

        <p>
          Let's talk about the memory for a second.
        </p>
      </section>

      <section>
        <h2>Memory</h2>

        <p>
          The memory is really a representation of the state of the zcode program at any given time. Consider the "state" you will be dealing with in two categories.
        </p>

        <p>
          The first category is a large array of bytes that is logically the memory of the virtual machine. This memory contains all the code, all the strings, and all the data structures representing every object in the zcode program. This memory also includes all the global variables. This first category is the "story state" or "game state" or "program state."
        </p>

        <p>
          The second category is consists of local variables for routines, a call stack that indicates what routines have been called, and temporary storage for handling the results of calculations in routines. This second category is the "interpreter state."
        </p>

        <p>
          An interpreter implementation takes as its input a file which is just a straight up serialization of the story state. When you're writing something like Entharion, you will spend a whole lot a lot of time figuring out how to decode that state.
        </p>

        <p>
          An interesting thing to consider is that in the Z-Machine, almost all of the memory stays the same all the time. All the code, all the strings: they don't ever change. In <em>Zork</em>, for example, there are apparently only a few thousand bytes that change through the course of any given playthrough of the game. And of those, very few of those bytes change with most instructions that are executed.
        </p>

        <p>
          The Z-Machine could address up to 64K of memory at any given time, but the total memory required by a given program might be much larger than this. In fact, the memory state of a zcode program was typically more than would fit into an 8-bit machine like the TRS-80, Commodore 64 or the Apple II. To accommodate this, the Z-Machine implemented a system of "memory windows", which were essentially smaller sections of memory that could be swapped in and out of the 64K address space as needed. The memory windows were typically used to hold the program's code, data, and stack, as well as any additional data structures required by the program.
        </p>

        <p>
          Thus Z-Machine interpreters typically used a technique called "bank switching." When the Z-Machine needed to access a part of memory that was not currently in the active bank, it would "switch" to the appropriate bank by copying the contents of the current bank's memory window to disk, loading the new bank's memory window from disk, and then continuing execution.
        </p>

        <p>
          In the context of the Z-Machine, a 16-bit pointer is used to address memory locations in a program's virtual memory space. This particular size of the pointer used in the Z-Machine was a design choice made by the machine's creators. They chose to use a 16-bit pointer because it was sufficient to address the memory space of the Z-Machine and more efficient than using a larger pointer size. Using a larger pointer size would have required more memory to store the same amount of information, and also would have increased the computational overhead needed to manipulate the pointers.
        </p>

        <p>
          But, given the above discussion of memory, the Z-Machine's memory state size can be larger than can be addressed with a 16-bit pointer. To address this, the Z-Machine uses a segmented memory model, in which memory is divided into smaller chunks called "pages." The interpreter keeps track of which page a particular memory address belongs to, and uses a separate pointer to index into the current page. This allows the interpreter to access a much larger memory space than would be possible with a single 16-bit pointer.
        </p>

        <p>
          The concepts of "pages" and "banks" are related to the memory regions of the Z-Machine, such as "dynamic" and "static." In particular, the memory management scheme of the Z-Machine involves dividing the memory into different regions, each with its own characteristics and limitations.
        </p>

        <p>
          The "static" memory region is where the read-only data of the program file is stored, including the program's text strings, and other data. The "dynamic" memory region, on the other hand, is used for the runtime state of the program, essentially involving mutable data. In the context of a game, this would be things like the player's current location, inventory items, and so on.
        </p>

        <p>
          Dynamic memory is allocated using 16-bit pointers and can be accessed directly. However, certain parts of static memory may require 17-bit pointers to address all the necessary data. To access these parts of memory, the Z-Machine uses indirect addressing, where a 16-bit pointer points to a table that contains 17-bit pointers to the actual data. The Z-Machine interpreter then uses bank switching to manage the different regions of memory and handle that indirect addressing.
        </p>

        <p>
          It's worth noting that the least significant bit of a 17-bit pointer is always 0 in this context. This is because the Z-Machine memory is divided into 2-byte units, which means that every address in memory is an even number. By setting the least significant bit of a 17-bit pointer to 0, the Z-Machine ensures that all addresses accessed with 17-bit pointers are aligned to these 2-byte units. This alignment was very important for efficient memory access, as unaligned memory accesses could be slower and less efficient and that meant quite a bit when dealing with the 8-bit machines of the time.
        </p>

        <p>
          Because the Z-Machine used 2-byte units for addressing memory, every address had to be divisible by 2. So to access anything beyond the first 64K of memory, the Z-Machine used 17-bit addresses with the bottom bit set to 0, allowing for the address to be represented as a 2-byte value. This means that all memory addresses beyond 64K had to start on an even boundary.
        </p>

        <p>
          The term "packed address" in the context of the Z-Machine refers to the fact that addresses in memory are stored using a variable-length encoding scheme that packs multiple address bits into a single byte or word. This was done in order to save memory space. The packed address encoding scheme allowed the Z-Machine to use a smaller memory footprint without sacrificing addressability.
        </p>

        <p>
          That term of "packed address" refers specifically to the 17-bit addresses used for accessing memory beyond 64K, and the fact that they are stored as 2-byte units with the bottom bit of the first byte always set to 0. Packed addresses are not relevant to the 16-bit addresses used for memory within the first 64K of the Z-Machine memory.
        </p>

        <p>
          Also, I should that earlier when I said that certain addresses above 64K are stored using "a variable-length encoding scheme," what I mean is that the actual number of bytes used to store the address may vary depending on the value of the address being stored. In other words, some addresses may require more bytes to be stored than others. For example, if the address being stored is less than 0x10000 (i.e., less than 64K), it can be stored in 2 bytes using a standard 16-bit pointer. However, if the address is greater than or equal to 0x10000, it can't be stored in 2 bytes and a variable-length encoding scheme must be used.
        </p>

        <p>
          So, going with what I've already described, one common encoding scheme is to use a 17-bit value with the low bit set to 0 to indicate that it is a packed address. If the 17-bit value is less than 0x1F000, then the packed address is just the 17-bit value shifted left by 1 bit. However, if the 17-bit value is greater than or equal to 0x1F000, then it's necessary to use more than 1 byte to store the packed address. In this case, the packed address consists of the high 5 bits of the 17-bit value in the first byte, and the low 8 bits of the 17-bit value in the second byte. And thus a variable-length encoding scheme is used to store addresses that are greater than or equal to 0x10000 and the encoding scheme used depends on the value of the address being stored.
        </p>

        <p>
          I used the value 0x1F000 as my example specifically to illustrate how an address above 64K can be stored using a variable-length encoding scheme. In this scheme, the high-order bit of the 16-bit address field is set to 1 to indicate that the address is encoded using two bytes. The remaining 15 bits of the address field are used to store the 15 least significant bits of the actual address. The remaining 2 bits of the actual address are stored in the next byte, which is referred to as the "packed address byte."
        </p>

        <p>
          So for the example of 0x1F000, the high-order bit of the 16-bit address field would be set to 1 to indicate that the address is encoded using two bytes. The remaining 15 bits would store the 15 least significant bits of the actual address, which in this case is 0x0F000. The remaining 2 bits (0x10) would be stored in the packed address byte, resulting in a packed address of 0x1F080.
        </p>

        <p>
          The dynamic memory of a Z-Machine program would be kept in physical memory, while the static memory was paged in and out as needed. The static memory was divided into "pages," and each page was loaded from the game file into memory when it was needed. When the Z-Machine needed to access data on a page that wasn't currently loaded, it would trigger a page fault, which would cause the interpreter to load the necessary page from the game file into memory, and then continue execution of the program.
        </p>

        <p>
          The Z-Machine stores all data, including instructions, strings, numbers, and addresses, as 2-byte units or "words". In cases where only one byte is needed to store data, a whole 2-byte word would still be used to store that data, with the other byte left unused. However, when accessing the memory, the Z-Machine would only need to reference the single byte that contains the actual data, and ignore the other byte. This can result in some memory wastage if there are many instances where only one byte is needed but two bytes are used. This is especially true if the program requires a lot of memory for its data. However, using a uniform word size simplifies memory management and access, which can be a trade-off worth making in some cases. Additionally, some Z-Machine story files use compression techniques to reduce the size of the file, which can help mitigate the memory usage impact of using 2-byte words.
        </p>

        <p>
          In the Z-Machine, a word is stored as two bytes in big-endian byte order, meaning the most significant byte (MSB) is stored first, followed by the least significant byte (LSB). For example, if the word 0xABCD is stored in memory, it would be stored as two bytes 0xAB followed by 0xCD. When we read a word from memory, we need to combine these two bytes to form the original word.
        </p>

        <p>
          So consider this to read a byte and a word:
        </p>

        <pre>
          return data[address]
          return (data[address] << 8) | data[address+1]
        </pre>

        <p>
          Here <code>data[addr]</code> and <code>data[addr + 1]</code> read the two bytes of the word from memory. We shift the MSB 8 bits to the left (&lt;&lt; 8) so that it occupies the upper 8 bits of the 16-bit integer, and then add the LSB to the lower 8 bits with a bitwise OR (|). The + 1 is included to handle the case where the word is a packed address. When the bottom bit of a packed address is 0, it means the address is relative to the start of the static memory area, which is at address 0. So we add 1 to the resulting value to convert it to an absolute address.
        </p>

        <p>
          Here's a schematic to help illustrate this:
        </p>

        <pre>
          Data in memory         MSB   LSB
          --------------         ---   ---
          Byte at addr           0xAB  0xCD
          Byte at addr + 1       0xCD  0xEF
          
          Value of (data[addr] << 8) 0xAB00
          Value of data[addr + 1]     0xCD
          Result of OR operation     0xABCD
          
          Packed address 0x3E    MSB   LSB
          -------------------    ---   ---
          Byte at 0x3E           0x1F  0x23
          
          Value of (data[0x3E] << 8) 0x1F00
          Value of data[0x3F]         0x23
          Result of OR operation      0x1F23 + 1 = 0x1F24
        </pre>

        <p>
          The first 64KB of static memory can be accessed using 16-bit pointers, just like the dynamic memory.
        </p>

        <p>
          The high memory is essentially a contiguous block of memory that is a subset of the static memory, and its start is indicated by the high memory mark. It is a special part of the static memory because it can only be accessed using 17-bit pointers due to its location beyond the 64K address range that can be addressed with 16-bit pointers.
        </p>
      </section>

      <section>
        <p>
          A zcode instruction is a sequence of bytes, describing an operation for the Z-Machine to perform. An instruction consists of two parts: the opcode and the operands. Each instruction has an operation byte, which is the byte containing the opcode.
        </p>

        <p>
          I handle this via a <code>decode()</code> method on an <code>Instruction</code> instance. An instance of this class is created every time an instruction is read from memory. The instruction instance is always passed a reference to wherever the program counter is pointing. Each instruction will be responsible for updating the program counter.
        </p>

        <p>
          The first thing <code>decode()</code> does is the following:
        </p>

        <pre>
          self.opcode_byte = self.memory_byte(self.address)
        </pre>

        <p>
          The operation byte is needed to understand how to determine the instruction form. Instructions come in different formats and this depends on the number of operands they take. The different forms are SHORT (zero or one operands), LONG (two operands), VARIABLE (up to four operands) or EXTENDED (up to four operands). There is a special form known as a DOUBLE VARIABLE (up to eight operands). It's worth noting that double variable forms are only available in Z-Machine version 4 and up. Extended forms are only available in Z-Machine version 5 and up.
        </p>

        <p>
          Everything is going to be writing some byte of data, schematically represented like this.
        </p>

        <svg xmlns="http://www.w3.org/2000/svg" version="1.0" width="265" height="116" viewBox="0 0 265 116"><text x="16" y="8" font-family="Courier New, monospace" font-size="11" dominant-baseline="middle" text-anchor="middle">7</text><text x="46" y="8" font-family="Courier New, monospace" font-size="11" dominant-baseline="middle" text-anchor="middle">6</text><text x="76" y="8" font-family="Courier New, monospace" font-size="11" dominant-baseline="middle" text-anchor="middle">5</text><text x="106" y="8" font-family="Courier New, monospace" font-size="11" dominant-baseline="middle" text-anchor="middle">4</text><text x="136" y="8" font-family="Courier New, monospace" font-size="11" dominant-baseline="middle" text-anchor="middle">3</text><text x="166" y="8" font-family="Courier New, monospace" font-size="11" dominant-baseline="middle" text-anchor="middle">2</text><text x="196" y="8" font-family="Courier New, monospace" font-size="11" dominant-baseline="middle" text-anchor="middle">1</text><text x="226" y="8" font-family="Courier New, monospace" font-size="11" dominant-baseline="middle" text-anchor="middle">0</text><path stroke="#000" d="M1 15h30M1 115h30"/><path stroke-dasharray="1,3" stroke="#000" d="M31 15v100"/><path stroke="#000" d="M1 15v100"/><text font-size="18" font-family="Courier New, monospace" x="16" y="66" text-anchor="middle" dominant-baseline="middle">1</text><path stroke="#000" d="M31 15h30M31 115h30"/><path stroke-dasharray="1,3" stroke="#000" d="M61 15v100M31 15v100"/><text font-size="18" font-family="Courier New, monospace" x="46" y="66" text-anchor="middle" dominant-baseline="middle">0</text><path stroke="#000" d="M61 15h30M61 115h30"/><path stroke-dasharray="1,3" stroke="#000" d="M91 15v100M61 15v100"/><text font-size="18" font-family="Courier New, monospace" x="76" y="66" text-anchor="middle" dominant-baseline="middle">1</text><path stroke="#000" d="M91 15h30M91 115h30"/><path stroke-dasharray="1,3" stroke="#000" d="M121 15v100M91 15v100"/><text font-size="18" font-family="Courier New, monospace" x="106" y="66" text-anchor="middle" dominant-baseline="middle">1</text><path stroke="#000" d="M121 15h30m-30 100h30"/><path stroke-dasharray="1,3" stroke="#000" d="M151 15v100M121 15v100"/><text font-size="18" font-family="Courier New, monospace" x="136" y="66" text-anchor="middle" dominant-baseline="middle">1</text><path stroke="#000" d="M151 15h30m-30 100h30"/><path stroke-dasharray="1,3" stroke="#000" d="M181 15v100M151 15v100"/><text font-size="18" font-family="Courier New, monospace" x="166" y="66" text-anchor="middle" dominant-baseline="middle">1</text><path stroke="#000" d="M181 15h30m-30 100h30"/><path stroke-dasharray="1,3" stroke="#000" d="M211 15v100M181 15v100"/><text font-size="18" font-family="Courier New, monospace" x="196" y="66" text-anchor="middle" dominant-baseline="middle">1</text><path stroke="#000" d="M211 15h30m-30 100h30m0-100v100"/><path stroke-dasharray="1,3" stroke="#000" d="M211 15v100"/><text font-size="18" font-family="Courier New, monospace" x="226" y="66" text-anchor="middle" dominant-baseline="middle">0</text></svg>

        <p>
          At this point, the operation byte has been read which gives us the opcode. If the opcode is 190 (0xBE in hexadecimal) and the version of the zcode porgram is 5 or later, the form is EXTENDED. If the top two bits of the opcode are <code>0b11</code> the form is VARIABLE. If the top two bits are <code>0b10</code>, the form is SHORT. If none of these conditions hold, the form is LONG. This is implemented in the <code>_determine_form()</code> method.
        </p>

        <pre>
          def _determine_form(self) -> None:
            if self.memory.version >= 5 and self.opcode_byte == 0xBE:
              self.form = Form.EXTENDED
            elif self.opcode_byte & 0b11000000 == 0b11000000:
              self.form = Form.VARIABLE
            elif self.opcode_byte & 0b10000000 == 0b10000000:
              self.form = Form.SHORT
            else:
              self.form = Form.LONG
        </pre>

        <p>
          With the form understood, it's now possible to get the exact operand count for the instruction. The operand count can be one of 0OP, 1OP, 2OP or VAR. So let's consider how this works for each of the forms.
        </p>

        <p>
          A SHORT form will either be 0OP or 1OP. In SHORT form, bits 4 and 5 of the opcode byte give the specific operand count. (The specification confusingly refers to this as the "operand type.") If bits 4 and 5 are 0b11 then the operand count is 0OP, otherwise the operand count is 1OP. What this means is that the opcode number is given in the bottom 4 bits.
        </p>

        <svg xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.0" width="242" height="116" viewBox="0 0 242 116"><text x="16" y="8" font-family="Courier New, monospace" font-size="11" dominant-baseline="middle" text-anchor="middle">7</text><text x="46" y="8" font-family="Courier New, monospace" font-size="11" dominant-baseline="middle" text-anchor="middle">6</text><text x="76" y="8" font-family="Courier New, monospace" font-size="11" dominant-baseline="middle" text-anchor="middle">5</text><text x="106" y="8" font-family="Courier New, monospace" font-size="11" dominant-baseline="middle" text-anchor="middle">4</text><text x="136" y="8" font-family="Courier New, monospace" font-size="11" dominant-baseline="middle" text-anchor="middle">3</text><text x="166" y="8" font-family="Courier New, monospace" font-size="11" dominant-baseline="middle" text-anchor="middle">2</text><text x="196" y="8" font-family="Courier New, monospace" font-size="11" dominant-baseline="middle" text-anchor="middle">1</text><text x="226" y="8" font-family="Courier New, monospace" font-size="11" dominant-baseline="middle" text-anchor="middle">0</text><line x1="1" y1="15" x2="31" y2="15" stroke="#000000" stroke-width="1"></line><line x1="1" y1="115" x2="31" y2="115" stroke="#000000" stroke-width="1"></line><line stroke-dasharray="1,3" x1="31" y1="15" x2="31" y2="115" stroke="#000000" stroke-width="1"></line><line x1="1" y1="15" x2="1" y2="115" stroke="#000000" stroke-width="1"></line><text font-size="18" font-family="Courier New, monospace" x="16" y="66" text-anchor="middle" dominant-baseline="middle">1</text><line x1="31" y1="15" x2="61" y2="15" stroke="#000000" stroke-width="1"></line><line x1="31" y1="115" x2="61" y2="115" stroke="#000000" stroke-width="1"></line><line stroke-dasharray="1,3" x1="61" y1="15" x2="61" y2="115" stroke="#000000" stroke-width="1"></line><line stroke-dasharray="1,3" x1="31" y1="15" x2="31" y2="115" stroke="#000000" stroke-width="1"></line><text font-size="18" font-family="Courier New, monospace" x="46" y="66" text-anchor="middle" dominant-baseline="middle">0</text><line x1="61" y1="15" x2="121" y2="15" stroke="#000000" stroke-width="1"></line><line x1="61" y1="115" x2="121" y2="115" stroke="#000000" stroke-width="1"></line><line stroke-dasharray="1,3" x1="121" y1="15" x2="121" y2="115" stroke="#000000" stroke-width="1"></line><line stroke-dasharray="1,3" x1="61" y1="15" x2="61" y2="115" stroke="#000000" stroke-width="1"></line><text font-size="14" font-family="inherit" writing-mode="vertical-rl" x="91" y="66" text-anchor="middle" dominant-baseline="middle">operand type</text><line x1="121" y1="15" x2="241" y2="15" stroke="#000000" stroke-width="1"></line><line x1="121" y1="115" x2="241" y2="115" stroke="#000000" stroke-width="1"></line><line x1="241" y1="15" x2="241" y2="115" stroke="#000000" stroke-width="1"></line><line stroke-dasharray="1,3" x1="121" y1="15" x2="121" y2="115" stroke="#000000" stroke-width="1"></line><text font-size="14" font-family="inherit" x="181" y="66" text-anchor="middle" dominant-baseline="middle">opcode number</text></svg>

        <p>
          The LONG form is easy since the operand count is always 2OP. This means the opcode number is given in the bottom 5 bits.
        </p>

        <svg xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.0" width="242" height="116" viewBox="0 0 242 116"><text x="16" y="8" font-family="Courier New, monospace" font-size="11" dominant-baseline="middle" text-anchor="middle">7</text><text x="46" y="8" font-family="Courier New, monospace" font-size="11" dominant-baseline="middle" text-anchor="middle">6</text><text x="76" y="8" font-family="Courier New, monospace" font-size="11" dominant-baseline="middle" text-anchor="middle">5</text><text x="106" y="8" font-family="Courier New, monospace" font-size="11" dominant-baseline="middle" text-anchor="middle">4</text><text x="136" y="8" font-family="Courier New, monospace" font-size="11" dominant-baseline="middle" text-anchor="middle">3</text><text x="166" y="8" font-family="Courier New, monospace" font-size="11" dominant-baseline="middle" text-anchor="middle">2</text><text x="196" y="8" font-family="Courier New, monospace" font-size="11" dominant-baseline="middle" text-anchor="middle">1</text><text x="226" y="8" font-family="Courier New, monospace" font-size="11" dominant-baseline="middle" text-anchor="middle">0</text><line x1="1" y1="15" x2="31" y2="15" stroke="#000000" stroke-width="1"></line><line x1="1" y1="115" x2="31" y2="115" stroke="#000000" stroke-width="1"></line><line stroke-dasharray="1,3" x1="31" y1="15" x2="31" y2="115" stroke="#000000" stroke-width="1"></line><line x1="1" y1="15" x2="1" y2="115" stroke="#000000" stroke-width="1"></line><text font-size="18" font-family="Courier New, monospace" x="16" y="66" text-anchor="middle" dominant-baseline="middle">0</text><line x1="31" y1="15" x2="61" y2="15" stroke="#000000" stroke-width="1"></line><line x1="31" y1="115" x2="61" y2="115" stroke="#000000" stroke-width="1"></line><line stroke-dasharray="1,3" x1="61" y1="15" x2="61" y2="115" stroke="#000000" stroke-width="1"></line><line stroke-dasharray="1,3" x1="31" y1="15" x2="31" y2="115" stroke="#000000" stroke-width="1"></line><text font-size="14" font-family="inherit" writing-mode="vertical-rl" x="46" y="66" text-anchor="middle" dominant-baseline="middle">first type</text><line x1="61" y1="15" x2="91" y2="15" stroke="#000000" stroke-width="1"></line><line x1="61" y1="115" x2="91" y2="115" stroke="#000000" stroke-width="1"></line><line stroke-dasharray="1,3" x1="91" y1="15" x2="91" y2="115" stroke="#000000" stroke-width="1"></line><line stroke-dasharray="1,3" x1="61" y1="15" x2="61" y2="115" stroke="#000000" stroke-width="1"></line><text font-size="14" font-family="inherit" writing-mode="vertical-rl" x="76" y="66" text-anchor="middle" dominant-baseline="middle">second type</text><line x1="91" y1="15" x2="241" y2="15" stroke="#000000" stroke-width="1"></line><line x1="91" y1="115" x2="241" y2="115" stroke="#000000" stroke-width="1"></line><line x1="241" y1="15" x2="241" y2="115" stroke="#000000" stroke-width="1"></line><line stroke-dasharray="1,3" x1="91" y1="15" x2="91" y2="115" stroke="#000000" stroke-width="1"></line><text font-size="14" font-family="inherit" x="166" y="66" text-anchor="middle" dominant-baseline="middle">opcode number</text></svg>

        <p>
          What the above shows is that the LONG form is implicitly defined as "not a leading 0b11 or 0b10." That implies that the bit 7 <em>must</em> be zero. That also implies that bit 6 isn't needed to define the form. Yet the opcode number occupies the low five bits. So what does that mean for bit 5? Bits 5 and 6 have to do with the <em>actual</em> operand types, which gets confusing since the specification seems to conflate "operand count" and "operand types" sometimes.
        </p>

        <p>
          In VARIABLE form, if bit 5 is 0 then the count is 2OP. If bit 5 is 1, then the count is VAR. The opcode number is given in the bottom 5 bits.
        </p>

        <svg xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.0" width="242" height="116" viewBox="0 0 242 116"><text x="16" y="8" font-family="Courier New, monospace" font-size="11" dominant-baseline="middle" text-anchor="middle">7</text><text x="46" y="8" font-family="Courier New, monospace" font-size="11" dominant-baseline="middle" text-anchor="middle">6</text><text x="76" y="8" font-family="Courier New, monospace" font-size="11" dominant-baseline="middle" text-anchor="middle">5</text><text x="106" y="8" font-family="Courier New, monospace" font-size="11" dominant-baseline="middle" text-anchor="middle">4</text><text x="136" y="8" font-family="Courier New, monospace" font-size="11" dominant-baseline="middle" text-anchor="middle">3</text><text x="166" y="8" font-family="Courier New, monospace" font-size="11" dominant-baseline="middle" text-anchor="middle">2</text><text x="196" y="8" font-family="Courier New, monospace" font-size="11" dominant-baseline="middle" text-anchor="middle">1</text><text x="226" y="8" font-family="Courier New, monospace" font-size="11" dominant-baseline="middle" text-anchor="middle">0</text><line x1="1" y1="15" x2="31" y2="15" stroke="#000000" stroke-width="1"></line><line x1="1" y1="115" x2="31" y2="115" stroke="#000000" stroke-width="1"></line><line stroke-dasharray="1,3" x1="31" y1="15" x2="31" y2="115" stroke="#000000" stroke-width="1"></line><line x1="1" y1="15" x2="1" y2="115" stroke="#000000" stroke-width="1"></line><text font-size="18" font-family="Courier New, monospace" x="16" y="66" text-anchor="middle" dominant-baseline="middle">1</text><line x1="31" y1="15" x2="61" y2="15" stroke="#000000" stroke-width="1"></line><line x1="31" y1="115" x2="61" y2="115" stroke="#000000" stroke-width="1"></line><line stroke-dasharray="1,3" x1="61" y1="15" x2="61" y2="115" stroke="#000000" stroke-width="1"></line><line stroke-dasharray="1,3" x1="31" y1="15" x2="31" y2="115" stroke="#000000" stroke-width="1"></line><text font-size="18" font-family="Courier New, monospace" x="46" y="66" text-anchor="middle" dominant-baseline="middle">1</text><line x1="61" y1="15" x2="91" y2="15" stroke="#000000" stroke-width="1"></line><line x1="61" y1="115" x2="91" y2="115" stroke="#000000" stroke-width="1"></line><line stroke-dasharray="1,3" x1="91" y1="15" x2="91" y2="115" stroke="#000000" stroke-width="1"></line><line stroke-dasharray="1,3" x1="61" y1="15" x2="61" y2="115" stroke="#000000" stroke-width="1"></line><text font-size="14" font-family="inherit" writing-mode="vertical-rl" x="76" y="66" text-anchor="middle" dominant-baseline="middle">operand count</text><line x1="91" y1="15" x2="241" y2="15" stroke="#000000" stroke-width="1"></line><line x1="91" y1="115" x2="241" y2="115" stroke="#000000" stroke-width="1"></line><line x1="241" y1="15" x2="241" y2="115" stroke="#000000" stroke-width="1"></line><line stroke-dasharray="1,3" x1="91" y1="15" x2="91" y2="115" stroke="#000000" stroke-width="1"></line><text font-size="14" font-family="inherit" x="166" y="66" text-anchor="middle" dominant-baseline="middle">opcode number</text></svg>

        <p>
          In EXTENDED form, the operand count is always VAR. The opcode number is given in a second opcode byte. I'll come back to that. First let's consider the logic that implements what I just talked about. I use the <code>_determine_operand_count()</code> and <code>_determine_opcode_number()</code> methods.
        </p>

        <pre>
          def _determine_operand_count(self) -> None:
            if self.form == Form.SHORT:
              if self.opcode_byte & 0b00110000 == 0b00110000:
                self.operand_count = Operand_Count.OP0
              else:
                self.operand_count = Operand_Count.OP1

            if self.form == Form.LONG:
              self.operand_count = Operand_Count.OP2

            if self.form == Form.VARIABLE:
              if self.opcode_byte & 0b00100000 == 0b00100000:
                self.operand_count = Operand_Count.VAR
              else:
                self.operand_count = Operand_Count.OP2

            if self.form == Form.EXTENDED:
              self.operand_count = Operand_Count.VAR
        </pre>

        <pre>
          def _determine_opcode_number(self) -> None:
            if self.form in (Form.LONG, Form.VARIABLE):
              self.opcode_number = self.opcode_byte & 0b00011111

            if self.form == Form.SHORT:
              self.opcode_number = self.opcode_byte & 0b00001111
        </pre>

        <p>
          All of the above is called like this:
        </p>

        <pre>
          self.opcode_byte = self.memory.read_byte(self.address)

          self._determine_form()
          self._determine_operand_count()
          self._determine_opcode_number()
        
          current_byte += 1
        </pre>

        <p>
          Crucial here is that the current byte being read is moved forward at this point. This will let us get to the actual operands and their types. But in the case of an extended instruction, we have to, as stated above, read the second byte.
        </p>

        <pre>
          if self.memory.version >= 5 and self.opcode_byte == 0xBE:
            self.opcode_number = self.memory.read_byte(current_byte)
            current_byte += 1
        </pre>

        <p>
          Notice here that the current byte has to be moved forward again. But this is crucial to note. The current byte must be moved forward consistently so that the appropriate next bytes can be read. In the case of an extended instruction, we've had to move past two bytes. In the case of non-extended instructions, we've had to move past one byte.
        </p>

        <p>
          Each opcode has a symbolic name -- a mnemonic -- that describes its effect. With the information gathered so far, it's possible to get the opcode name, as used in the specification, that is associated with the instruction. This is handled by the <code>_determine_opcode_name()</code> method.
        </p>

        <pre>
          def _determine_opcode_name(self) -> None:
            for opcode in opcodes:
              if opcode.matches(
                self.memory.version, self.opcode_byte, self.opcode_number
              ):
                self.opcode_name = opcode.name
        </pre>

        <p>
          Now that we have a count of the operands for a given instructions, we can get the types of however many operands there are. What's crucial here is that we're still reading the opcode byte for SHORT and LONG instructions. Let's consider SHORT form first.
        </p>

        <p>
          Rememmber that in SHORT form, bits 4 and 5 of the opcode byte give the specific operand count: 0b11 means 0OP, 0b10 means 1OP. What can be confusing is that, according to the specification, in SHORT form, bits 4 and 5 of the opcode also give the type.
        </p>

        <p>
          There are four "types" of operand that are possible and these are specified by a number stored in two binary digits. 0b00 refers to a large (word) constant whose values run from 0 to 65535, thus taking up two bytes. 0b01 refers to a small (byte) constant whose values run from 0 to 255, thus taking up one byte. 0b10 refers to a variable number, taking up one byte. 0b11 means that the operand has been omitted and thus it takes up no bytes.
        </p>

        <p>
          Earlier it was shown that, with LONG form, bits 5 and 6 seemed a bit unused. Now we can get into what those <em>are</em> used for. In LONG form, bit 6 of the opcode gives the type of the first operand and bit 5 gives the type of the second operand. The specification says that "a value of 0 means a small constant and 1 means a variable." Which is interesting because that contradicts what the operand types are given as, where 0b00 refers to a large constant and 0b01 refers to a small constant.
        </p>

        <p>
          It <em>does</em>, however, make sense when you consider the possible variations. Here's how the byte can look. The first bit will always be 0. That's what makes it a LONG. The next two bits are the ones in question and then I use x's to indicate the bottom bits.
        </p>

        <ul>
          <li>0 10 xxxxx (variable)</li>
          <li>0 00 xxxxx (large; not handled)</li>
          <li>0 01 xxxxx (small)</li>
          <li>0 11 xxxxx (omitted)</li>
        </ul>

        <p>
          There you can see how this matches up with the operand types. The specification makes none of this very clear. Why is the large not handled? The specification says: "If a 2OP instruction needs a large constant as operand, then it should be assembled in variable rather than long form."
        </p>

        <p>
          In VARIABLE or EXTENDED forms, a byte of four operand types is provided next. What's crucial here from the implementation standpoint is that the SHORT and LONG forms are using the opcode byte for the instruction to get the operand types. But the VARIABLE and EXTENDED forms require the next byte.
        </p>

        <p>
          For the VARIABLE and EXTENDED forms, the next byte that contains four operand types is made up of four 2-bit fields: bits 6 and 7 are the first field, bits 0 and 1 the fourth. The values are the same operand types discussed earlier: 00 (large), 01 (small), 10 (variable), 11 (omitted). If any operand is markeda s omitted, then no other operands can follow.
        </p>

        <p>
          All of the above logic is handled in the <code>_determine_operand_types()</code> method.
        </p>

        <p>
          After all of that, the operands are provided next or, rather, their values. The number of operands that the instruction contains depends on the count: no operands for 0OP, one operand for 1OP, and two operands for 2OP. A VAR operand count means there are as many operands as there were non-omitted types.
        </p>

        <p>
          Some instructions return a result. These instructions are followed by a single byte called a result argument. The specifications calls these "store instructions." This byte is the number of the variable where the result should be stored and what this means is that it looks like an additional operand of type 10 (binary). But what does that mean?
        </p>

        <p>
          This goes back to those types of operands, where the values could be 00 (large constant), 01 (small constant), and 10 (variable). Here the "variable" doesn't mean "variable" in the context of the form or operand type (like VAR) but rather literally refers to a type of variable.
        </p>
      </section>
    </article>
  </main>
</body>
</html>
